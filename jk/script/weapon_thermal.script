/***********************************************************************

weapon_thermal.script

***********************************************************************/

#define THERMAL_MINRELEASETIME		0.05
#define THERMAL_FUSE				3
#define THERMAL_QUICKTHROWTIME		.2
#define THERMAL_MINPOWER			1.5
#define THERMAL_MAXPOWER			6
#define THERMAL_QUICKTHROWLAUNCH	0.55
#define THERMAL_NORMALTHROWLAUNCH	0.3
#define THERMAL_NUMPROJECTILES		1

// blend times
#define THERMAL_IDLE_TO_LOWER		4
#define THERMAL_IDLE_TO_FIRE		4
#define THERMAL_RAISE_TO_IDLE		4
#define THERMAL_FIRE_TO_IDLE		4

scriptEvent string getIdealWeapon();


object weapon_thermal : weapon_base {
	float		spread;
	float		fuse_start;
	string		skin_nade;
	string		skin_nade_invis;
	string		skin_nonade;
	string		skin_nonade_invis;
	entity		projectile;
	
	boolean		show_grenade;
	
	void		init();
	
	void		Lower();
	void		Raise();
	void		Idle();
	void		Fire();
	void		EnterCinematic();
	void		ExitCinematic();
	void		WeaponStolen();
	void		OwnerDied();
	void		ExplodeInHand();
	
				// called by the game
	void		UpdateSkin();
	
				// used by anim frame commands
	void		GrenadeNade();
	void		GrenadeNoNade();
};

void weapon_thermal::init() {
	spread				= getFloatKey( "spread" );
	skin_nade			= getKey( "skin_nade" );
	skin_nade_invis		= getKey( "skin_nade_invis" );
	skin_nonade			= getKey( "skin_nonade" );
	skin_nonade_invis	= getKey( "skin_nonade_invis" );
	
	GrenadeNade();
	
	weaponState( "Raise", 0 );
}

void weapon_thermal::Raise() {
	if ( !ammoAvailable() ) {
		weaponHolstered();
		nextWeapon();
		return;
	}
	
	weaponRising();
	playAnim( ANIMCHANNEL_ALL, "raise" );
	waitUntil( animDone( ANIMCHANNEL_ALL, THERMAL_RAISE_TO_IDLE ) );

	weaponState( "Idle", THERMAL_RAISE_TO_IDLE );
}

void weapon_thermal::Lower() {
	weaponLowering();
	playAnim( ANIMCHANNEL_ALL, "putaway" );
	waitUntil( animDone( ANIMCHANNEL_ALL, 0 ) );
	weaponHolstered();
	waitUntil( WEAPON_RAISEWEAPON );
	weaponState( "Raise", 0 );
}

void weapon_thermal::Idle() {
	weaponReady();
	playCycle( ANIMCHANNEL_ALL, "idle" );
	while( 1 ) {
		if ( WEAPON_LOWERWEAPON ) {
			weaponState( "Lower", THERMAL_IDLE_TO_LOWER );
		}
		if ( WEAPON_ATTACK || WEAPON_NETFIRING ) {
			weaponState( "Fire", THERMAL_IDLE_TO_FIRE );
		} else if ( WEAPON_ATTACK_ALT || WEAPON_NETFIRING ) {
			weaponState( "AltFire", THERMAL_IDLE_TO_FIRE );
		}
		waitFrame();
	}
}

void weapon_thermal::Fire() {
	float fuse_end;
	float current_time;
	float time_held;
	float power;
	boolean exploded;
	entity	owner;
	
	projectile = createProjectile();

	if ( projectile ) {
		projectile.startSound( "snd_throw", SND_CHANNEL_BODY, true );
	}

	playAnim( ANIMCHANNEL_ALL, "throw_start" );
	
	current_time = sys.getTime();
	fuse_start = current_time;
	fuse_end = current_time + THERMAL_FUSE;
	while( current_time < fuse_end ) {
		if ( ( current_time > fuse_start + THERMAL_MINRELEASETIME ) && !( WEAPON_ATTACK || WEAPON_NETFIRING ) ) {
			break;
		}
		waitFrame();
		current_time = sys.getTime();
	}
	
	time_held = current_time - fuse_start;
	power = time_held + THERMAL_MINPOWER;
	if ( power > THERMAL_MAXPOWER ) {
		power = THERMAL_MAXPOWER;
	}

	if ( time_held < THERMAL_QUICKTHROWTIME ) {
		playAnim( ANIMCHANNEL_ALL, "throw_quick" );
		sys.wait( THERMAL_QUICKTHROWLAUNCH );
		exploded = false;
	} else if ( time_held < THERMAL_FUSE + 50 ) {
		playAnim( ANIMCHANNEL_ALL, "throw" );
		sys.wait( THERMAL_NORMALTHROWLAUNCH	);
		exploded = false;
	} else {
		// no anim.  grenade just blows up
		ExplodeInHand();
		exploded = true;
	}
	
	if ( !exploded ) {
		GrenadeNoNade();
		current_time = sys.getTime();
		if ( projectile ) {
			projectile.show();
			projectile.unbind();
			launchProjectiles( THERMAL_NUMPROJECTILES, spread, current_time - fuse_start, power, 1.0 );
			projectile = $null_entity;
		}

		waitUntil( animDone( ANIMCHANNEL_ALL, THERMAL_FIRE_TO_IDLE ) );
	}

	if ( !ammoAvailable() ) {
		weaponHolstered();
		owner = getOwner();
		if ( owner.getIdealWeapon() == "weapon_thermal" ) {	
			nextWeapon();
		}
	} else {
		GrenadeNade();
		weaponState( "Idle", THERMAL_FIRE_TO_IDLE );
	}
}
void weapon_thermal::AltFire() {
	float fuse_end;
	float current_time;
	float time_held;
	float power;
	boolean exploded;
	entity	owner;
	
	//This creates the projectile early so it can track and transfer the fuse time over to the nade, my alt fire thing doesn't 
	//work properly with that yet because the create projectile thing isn't supporterd
	projectile = createProjectile();

	if ( projectile ) {
		projectile.startSound( "snd_throw", SND_CHANNEL_BODY, true );
	}

	playAnim( ANIMCHANNEL_ALL, "throw_start" );
	
	current_time = sys.getTime();
	fuse_start = current_time;
	fuse_end = current_time + THERMAL_FUSE;
	while( current_time < fuse_end ) {
		if ( ( current_time > fuse_start + THERMAL_MINRELEASETIME ) && !( WEAPON_ATTACK_ALT || WEAPON_NETFIRING ) ) {
			break;
		}
		waitFrame();
		current_time = sys.getTime();
	}
	
	time_held = current_time - fuse_start;
	power = time_held + THERMAL_MINPOWER;
	if ( power > THERMAL_MAXPOWER ) {
		power = THERMAL_MAXPOWER;
	}

	if ( time_held < THERMAL_QUICKTHROWTIME ) {
		playAnim( ANIMCHANNEL_ALL, "throw_quick" );
		sys.wait( THERMAL_QUICKTHROWLAUNCH );
		exploded = false;
	} else if ( time_held < THERMAL_FUSE + 50 ) {
		playAnim( ANIMCHANNEL_ALL, "throw" );
		sys.wait( THERMAL_NORMALTHROWLAUNCH	);
		exploded = false;
	} else {
		// no anim.  grenade just blows up
		ExplodeInHand();
		exploded = true;
	}
	
	if ( !exploded ) {
		GrenadeNoNade();
		current_time = sys.getTime();
		
		if ( projectile ) {
			projectile.show();
			projectile.unbind();
			launchProjectilesAlt( THERMAL_NUMPROJECTILES, spread, current_time - fuse_start, power, 1.0 );
			projectile = $null_entity;
		}
		
		

		waitUntil( animDone( ANIMCHANNEL_ALL, 0 ) );
		//launchProjectilesAlt( THERMAL_NUMPROJECTILES, spread, current_time - fuse_start, power, 1.0 );
	}

	if ( !ammoAvailable() ) {
		weaponHolstered();
		owner = getOwner();
		if ( owner.getIdealWeapon() == "weapon_thermal" ) {	
			nextWeapon();
		}
	} else {
		GrenadeNade();
		weaponState( "Idle", THERMAL_FIRE_TO_IDLE );
	}
}

void weapon_thermal::EnterCinematic() {
	if ( projectile ) {
		projectile.remove();
		projectile = $null_entity;		
	}
	weaponState( "Idle", 0 );
}

void weapon_thermal::ExitCinematic() {
	if ( !ammoAvailable() ) {
		weaponHolstered();
		nextWeapon();
	} else {
		GrenadeNade();
		weaponState( "Idle", 0 );
	}
}

void weapon_thermal::GrenadeNade() {
	show_grenade = true;
	UpdateSkin();
}

void weapon_thermal::GrenadeNoNade() {
	show_grenade = false;
	UpdateSkin();
}

void weapon_thermal::UpdateSkin() {
	if ( !show_grenade ) {
		if ( isInvisible() ) {
			setSkin( skin_nonade_invis );
		} else {
			setSkin( skin_nonade );
		}
	} else {
		if ( isInvisible() ) {
			setSkin( skin_nade_invis );
		} else {
			setSkin( skin_nade );
		}
	}
}

void weapon_thermal::WeaponStolen() {
	if ( projectile ) {
		projectile.remove();
		projectile = $null_entity;		
	}
}

void weapon_thermal::OwnerDied() {
	float time_held;

	if ( projectile ) {
		time_held = sys.getTime() - fuse_start;
		projectile.show();
		projectile.unbind();

		// allow grenade to drop
		launchProjectiles( THERMAL_NUMPROJECTILES, spread, time_held, 0, 1.0 );

		projectile = $null_entity;
	}
}

void weapon_thermal::ExplodeInHand() {
	string	entname;
	entity	explosion;
	vector	forward;
	vector	angles;
	entity	owner;

	if ( projectile ) {
		projectile.remove();
		projectile = $null_entity;
	}

	owner = getOwner();

	GrenadeNoNade();
	startSound( "snd_explode", SND_CHANNEL_ANY, false );

	if ( !sys.isClient() ) {
		useAmmo( THERMAL_NUMPROJECTILES );

		angles = owner.getViewAngles();
		forward = sys.angToForward( angles );

		entname = getKey( "def_explode_inhand" );
		explosion = sys.spawn( entname );
		explosion.setOrigin( getOrigin() + forward * 16 );
		explosion.setShaderParm( SHADERPARM_TIMEOFFSET, -sys.getTime() );
		delayRemove( explosion, 2 );

		// this should kill us
		sys.radiusDamage( getOrigin(), self, owner, $null_entity, getKey( "def_damage_inhand" ), 1.0 );
	}
}

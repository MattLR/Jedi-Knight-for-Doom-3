/***********************************************************************

weapon_bowcaster.script

***********************************************************************/

#define BOWCASTER_FIRERATE			0.35
#define BOWCASTER_ALTFIRERATE	0.5
#define BOWCASTER_LOWAMMO			4
#define BOWCASTER_NUMPROJECTILES	1

// blend times
#define BOWCASTER_IDLE_TO_LOWER	2
#define BOWCASTER_IDLE_TO_FIRE		1
#define	BOWCASTER_IDLE_TO_RELOAD	3
#define BOWCASTER_RAISE_TO_IDLE	3
#define BOWCASTER_FIRE_TO_IDLE		4
#define BOWCASTER_RELOAD_TO_IDLE	4

object weapon_bowcaster : weapon_base {
	float		next_attack;
	float		spread;
	boolean 	AltFireB;
	
	void		init();
	
	void		Lower();
	void		Raise();
	void		Idle();
	void		Fire();
	void		AltFire();
	void		Reload();
	void		ExitCinematic();
};

void weapon_bowcaster::init() {
	next_attack = 0;
	spread		= getFloatKey( "spread" );
	weaponState( "Raise", 0 );
}

void weapon_bowcaster::Raise() {
	weaponRising();
	playAnim( ANIMCHANNEL_ALL, "raise" );
	waitUntil( animDone( ANIMCHANNEL_ALL, BOWCASTER_RAISE_TO_IDLE ) );
	weaponState( "Idle", BOWCASTER_RAISE_TO_IDLE );
}

void weapon_bowcaster::Lower() {
	weaponLowering();
	playAnim( ANIMCHANNEL_ALL, "putaway" );
	waitUntil( animDone( ANIMCHANNEL_ALL, 0 ) );
	weaponHolstered();
	waitUntil( WEAPON_RAISEWEAPON );
	weaponState( "Raise", 0 );
}

void weapon_bowcaster::Idle() {
	float currentTime;
	float ammoClip;
	float avail;
	float clip_size;
	
	clip_size = clipSize();	
	//AltFireB = FALSE;
	weaponReady();
	playCycle( ANIMCHANNEL_ALL, "idle" );

	while( 1 ) {
		if ( WEAPON_LOWERWEAPON ) {
			weaponState( "Lower", BOWCASTER_IDLE_TO_LOWER );
		}
		currentTime = sys.getTime();
		if ( ( currentTime >= next_attack ) && WEAPON_ATTACK ) {
			weaponState( "Fire", BOWCASTER_IDLE_TO_FIRE );
		} else if ( ( currentTime >= next_attack ) && WEAPON_ATTACK_ALT) {
			weaponState( "AltFire", BOWCASTER_IDLE_TO_FIRE );
		}
		waitFrame();
	}
}

void weapon_bowcaster::Fire() {

	next_attack = sys.getTime() + BOWCASTER_FIRERATE;
	
	float	powerScale;
	float projectiles;
	projectiles = 1;
	powerScale = 1.0;

	//startSound( "snd_charge", SND_WEAPON_MOVE );
	playAnim( ANIMCHANNEL_ALL, "fire_begin" );

	while ( true ) {
			sys.waitFrame();

			if ( !WEAPON_ATTACK || WEAPON_LOWERWEAPON ) {
				break;
			}

			powerScale = powerScale + ( sys.getFrameTime() * 1.6f );
			if (powerScale > 3){
				projectiles = 3;
			}
			if ( powerScale > 5.0 ) {
				/*
				if ( !effectPlaying ) {
					if ( sys.getLocalViewPlayer() != myPlayer || pm_thirdperson.getBoolValue() ) {
						worldModel.killEffect( "fx_charge_muzzle_world" );
						worldModel.playEffect( "fx_charge_muzzle_loop_world", "muzzle", 1 );
					} else {
						if ( !ironSightsEnabled ) {
							fx2 = spawnClientEffect( "fx_charge_muzzle_loop" );
							if ( fx2 != $null_entity ) {
								fx2.bindToJoint( self, "muzzle", 1 );
								fx2.setEffectLooping( 1 );
							}
						}
					}
					effectPlaying = true;
				}
				*/
				powerScale = 5.0;
				projectiles = 5;
			}
				//setChannelPitchShift( SND_WEAPON_MOVE, powerScale * 2.f );
		}

	launchProjectiles( projectiles, spread, 0, 1.0, 1.0 );
	playAnim( ANIMCHANNEL_ALL, "fire" );
	waitUntil( animDone( ANIMCHANNEL_ALL, BOWCASTER_FIRE_TO_IDLE ) );
	weaponState( "Idle", BOWCASTER_FIRE_TO_IDLE );
}

void weapon_bowcaster::AltFire() {

	next_attack = sys.getTime() + BOWCASTER_ALTFIRERATE;
	
	launchProjectilesAlt( BOWCASTER_NUMPROJECTILES, 0, 0, 1.0, 1.0 );
	playAnim( ANIMCHANNEL_ALL, "fire" );
	waitUntil( animDone( ANIMCHANNEL_ALL, BOWCASTER_FIRE_TO_IDLE ) );
	weaponState( "Idle", BOWCASTER_FIRE_TO_IDLE );
}

void weapon_bowcaster::Reload() {
	weaponReloading();
	playAnim( ANIMCHANNEL_ALL, "reload" );
	waitUntil( animDone( ANIMCHANNEL_ALL, BOWCASTER_RELOAD_TO_IDLE ) );
	addToClip( clipSize() );
	weaponState( "Idle", BOWCASTER_RELOAD_TO_IDLE );
}

void weapon_bowcaster::ExitCinematic() {
	next_attack = 0;
	weaponState( "Idle", 0 );
}
